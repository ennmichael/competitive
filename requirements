Basics:

- (ON HOLD) Binary exponentation
    Okay, but do you really think your implementation of binary exp could be faster
    than GCC's? I just checked; std::pow in GCC's implementation delegates to a builtin.
    Which means, not only do they use binary exponentation, they also use special
    instructions where available. Implementing this is a waste of time.
    TODO When they publish which version of GCC they'll be using, check the implementation on that version too.
- Checking if a number is prime - primality test
- (DONE) Sieve of Eratosthenes
- Number factorization algorithms (this should be O(sqrt(N))
- (DONE) Euclid's algorithm
    NZD - najveći zajednički delilac = GCD - greatest common divisor
    NZS - najmanji zajednički sadržalac = LCM - lowest common multiplier
                                        = a * b / gcd(a, b)
                                        = a / gcd(a, b) * b (This version is better because it avoids integer overflow)
- Generating combinatory objects - permutations, combinations, variations, etc. (this is under recursion/backtrack, interesting)
- Branch and bound
- (ON HOLD) Sorting - selection, insertion (isn't this garbage?), bubble, counting, quick sort (advanced), merge sort (advanced)
    Again, just use std::sort.
- Analytic geometry (lines, infinite line segments starting at a single point, intersections, euclidean distances)
    This is fun
- Greedy algorithms (???)
- Efficiently searching sorted arrays, including binary searching (advanced)

Advanced:

- Quickselect
- Solving "classical" (what the fuck is classical?) optimization problems
    Here they include: Knapsack problem, Longest increasing sequence, Longest common sequence 
- Graph theory (this is fucking boring, but seems important, so I may want to have this done for qualifications)
- Btrees and heaps
- Cross product and dot product of vectors, checking vector orientation
    I assume by vector orientation they mean how one vector is oriented in relation to another, but I'm not sure
- Polygon surface area
- Checking if a point belongs to a polygon
- Inclusion/exclusion combinatory principle
- Combinatory game theory - winning/losing positions
